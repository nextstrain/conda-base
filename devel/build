#!/bin/bash
set -euo pipefail
shopt -s extglob

source "$(dirname "$0")/_common"
cd "$repo"

main() {
    # First things first: set PATH early so everything that follows has the dev
    # env available.
    export PATH="$env/bin:$PATH"
    export VERSION="${VERSION:-$(./devel/generate-version)}"

    # Set CONDA_SUBDIR unless it's already set.
    CONDA_SUBDIR="${CONDA_SUBDIR:-$(./devel/conda-subdir)}"
    export CONDA_SUBDIR

    # Set CONDA_OVERRIDE_ARCHSPEC if it's unset or empty.
    if [[ -z "${CONDA_OVERRIDE_ARCHSPEC:-}" ]]; then
        # Unset CONDA_OVERRIDE_ARCHSPEC if it's set but empty.  An empty
        # archspec override *omits* the virtual __archspec package from
        # solving, and we don't want to do that.
        unset CONDA_OVERRIDE_ARCHSPEC

        case "$CONDA_SUBDIR" in
            linux-64|osx-64)
                # Avoid x86_64-microarch-level versions >1 for greatest
                # compatibility
                export CONDA_OVERRIDE_ARCHSPEC=x86_64;;

            # Other subdirs use their default.
        esac
    fi

    clean
    build src "$@"
    lock
    build locked "$@"
}

clean() {
    log "Removing $repo/build and $repo/locked"
    rm -rf ./build ./locked
}

build() {
    local recipe_dir="$1"
    shift

    log "Building $repo/$recipe_dir into $repo/build/$recipe_dir"

    rattler-build build \
        --channel conda-forge \
        --channel bioconda \
        --channel-priority strict \
        --package-format conda:22 \
        --output-dir "./build/$recipe_dir" \
        --recipe "$recipe_dir" \
        "$@"
}

lock() {
    log "Copying $repo/src to $repo/locked"
    cp -a src locked

    log "Updating $repo/locked/recipe.yaml"
    yq \
        --yaml-roundtrip \
        --slurpfile rendered <(rendered-recipe | yaml-to-json) \
        '
              .package.version = $rendered[0].recipe.package.version
            | .build.string = $rendered[0].recipe.build.string + "_locked"
            | .requirements.build = []
            | .requirements.host = []
            | .requirements.run = (
                  $rendered[0].finalized_dependencies.host.resolved
                | map("\(.channel)::\(.name) ==\(.version) \(.build)"))
        ' \
        < src/recipe.yaml \
        > locked/recipe.yaml
}

rendered-recipe() {
    # It would be really nice if we could use `rattler-build build
    # --render-only --with-solve` (or `conda render`) for this, but we can't
    # seem to.  Instead, extract the rendered recipe from the package built in
    # the first pass.
    #
    # Note that rattler-build doesn't guarantee the format of this rendered
    # recipe¹, so we might hit breakage in the future.
    #
    # ¹ <https://rattler.build/latest/package_spec/#inforecipe>
    local package="$(echo ./build/src/*/nextstrain-base-"$VERSION"-!(*_locked).conda)"
    ./devel/extract-pkg-info "$package" recipe/rendered_recipe.yaml
}

yaml-to-json() {
    yq '.'
}

main "$@"
